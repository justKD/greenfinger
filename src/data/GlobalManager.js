/**
 * @file GlobalManager.js
 * @version 0.1.0
 * @author justKD
 * @copyright justKD 2020
 * @license MIT https://notnatural.co/license/mit/
 * @fileoverview `export class GlobalManager`
 */

/**
 * Manage widely scoped entities by associating a UUID with every entry. Pass the
 * generated UUID string between differently scoped entities in order to reliably
 * access a single mutable reference. Release the widely scoped reference by deleting
 * the entry via the key or UUID.
 *
 * Generate RFC4122 version 4 compliant unique identifiers to manage key:UID associations.
 * Validates UIDs via regular expression and ensures all identifiers and references are unique
 * (per instance) by checking against existing entries held in the map.
 */
class GlobalManager {
  /**
   * Manage widely scoped entities by associating a UUID with every entry. Pass the
   * generated UUID string between differently scoped entities in order to reliably
   * access a single mutable reference. Release the widely scoped reference by deleting
   * the entry via the key or UUID.
   *
   * Generate RFC4122 version 4 compliant unique identifiers to manage key:UID associations.
   * Validates UIDs via regular expression and ensures all identifiers and references are unique
   * (per instance) by checking against existing entries held in the map.
   * @param {{prefix?: string, map?: Map}} params - Set the optional parameters.
   * @param {string?} params.prefix - Set a string to be prefixed to all UUIDs generated by this
   * instance. Avoid using the delimiter character (default `_`).
   * @param {Map} params.map - Instantiate this instance with a prexisting `Map`. It should probably
   * be another map exported via `new GlobalManager().entries()`. The map values must be RFC4122
   * version 4 compliant strings.
   * @example
   * ```
   * const manager = new GlobalManager();
   * const objID = manager.manage( { a: 1 } );
   *
   * let obj = manager.retrieve( objID ); // { a: 1}
   * let uid = manager.getUidFor( obj );
   *
   * console.log( manager.hasKeyFor( uid ) ); // true
   * console.log( manager.hasUidFor( obj ) ); // true
   *
   * manager.deleteEntryForUid( uid );
   *
   * console.log( manager.hasKeyFor( uid ) ); // false
   * console.log( manager.hasUidFor( obj ) ); // false
   * ```
   */
  constructor(params) {
    /**
     * Generate RFC4122 version 4 compliant unique identifiers using pseudo-random
     * values from `window.crypto` (with a fallback to `Math.Random`). A pre-generated
     * lookup table is used for performance optimization.
     * @note Based on discussions found here:
     * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
     * @note
     * ```
     * from kdjs-uuid
     * v0.1.0
     * ```
     */
    const getUuidGenerator = () => {
      /**
       * Lookup table holding 0-255 as hexadecimal numbers.
       */
      const lookup = Array(256)
        .fill(null)
        .map((_, i) => (i < 16 ? "0" : "") + i.toString(16));

      /**
       * Given an array of four random 32-bit unsigned integers, use the lookup table and
       * bitshift/bitwise operations to generate RFC4122 version 4 compliant unique identifier.
       * @param {[number, number, number, number]} values - Array holding four 32-bit unsigned integers.
       * @returns {string} - RFC4122 version 4 compliant unique identifier.
       */
      const formatUid = values => {
        const v = [
          lookup[values[0] & 0xff],
          lookup[(values[0] >> 8) & 0xff],
          lookup[(values[0] >> 16) & 0xff],
          lookup[(values[0] >> 24) & 0xff],
          lookup[values[1] & 0xff],
          lookup[(values[1] >> 8) & 0xff],
          lookup[((values[1] >> 16) & 0x0f) | 0x40],
          lookup[(values[1] >> 24) & 0xff],
          lookup[(values[2] & 0x3f) | 0x80],
          lookup[(values[2] >> 8) & 0xff],
          lookup[(values[2] >> 16) & 0xff],
          lookup[(values[2] >> 24) & 0xff],
          lookup[values[3] & 0xff],
          lookup[(values[3] >> 8) & 0xff],
          lookup[(values[3] >> 16) & 0xff],
          lookup[(values[3] >> 24) & 0xff],
        ];
        const s = [
          `${v[0]}${v[1]}${v[2]}${v[3]}`,
          `${v[4]}${v[5]}`,
          `${v[6]}${v[7]}`,
          `${v[8]}${v[9]}`,
          `${v[10]}${v[11]}${v[12]}${v[13]}${v[14]}${v[15]}`,
        ];
        return `${s[0]}-${s[1]}-${s[2]}-${s[3]}-${s[4]}`;
      };

      /**
       * Determine which prng to use and return an array of four 32-bit unsigned integers.
       * @returns {[number, number, number, number]}
       */
      const getRandomValues =
        window.crypto && window.crypto.getRandomValues
          ? () => {
              return Array.from(
                window.crypto.getRandomValues(new Uint32Array(4)),
              );
            }
          : () => {
              const rand = () => (Math.random() * 0x100000000) >>> 0;
              return [rand(), rand(), rand(), rand()];
            };

      /**
       * Generate RFC4122 version 4 compliant unique identifiers using random values from
       * `window.crypto` (with a fallback to `Math.Random`). A pre-generated lookup table
       * is used for performance optimization.
       */
      const uuid = {
        /**
         * Determine which pseudo-random number generator to use, generate four random
         * values, and coerce the output to a RFC4122 version 4 compliant unique identifier.
         * @returns {string}
         */
        generate: () => formatUid(getRandomValues()),
      };

      return uuid;
    };

    /**
     * Separator character used when applying prefixes.
     * Can not be alphanumeric characters or hyphen `-`.
     * Default is `_`.
     */
    const DELIM = "_";

    /**
     * Validation utility.
     */
    const validate = {
      /**
       *  Regular expression for validating RFC4122 version 4 compliant unique identifiers.
       */
      reV4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,

      /**
       * Validate a string as RFC4122 version 4 compliant unique identifier.
       * @param {string} uid
       * @returns {boolean}
       */
      isUid: uid => typeof uid === "string" && validate.reV4.test(uid),

      /**
       * Ensure the parameter is a valid `new Map()` parameter: either a `Map` or an
       * array consisting only of arrays of length 2.
       * @param {any} map
       * @returns {boolean}
       */
      isMap: map => {
        return (
          (map && map.constructor === Map) ||
          (Array.isArray(map) &&
            map.every(x => Array.isArray(x) && x.length === 2))
        );
      },

      /**
       * Assuming the parameter is a valid `new Map()` parameter, ensure the UID values are
       * all valid RFC4122 version 4 unique identifiers and all are actually unique.
       * @param {[any, string][]} map
       * @returns {boolean}
       */
      isUidMap: map => {
        const allAreUnique = Array.from(new Set(map)).length === map.length;
        return allAreUnique && map.every(uid => validate.isUid(uid));
      },

      /**
       * Ensure the parameter is a valid `new Map()` parameter and a valid `GlobalManager` map.
       * Strip any existing prefix off of the UIDs, validate each as a compliant string,
       * and then prefix the current prefix string to the UIDs. Throws appropriate errors
       * in the case any check fails.
       * @param {any} map - The map parameter on which to operate.
       * @param {string} [prefix] - The prefix that should be added to each existing UID.
       * @returns {[any, string][]|undefined}
       * @note If there is an existing prefix on any UID, it will be stripped and replaced
       * with the the current prefix.
       */
      validMapParam: (map, prefix) => {
        if (map) {
          /* Error handling. */
          const notMapError = "Map param must be a valid `new Map()` param.";
          const notUIDError = "Map param contains invalid or duplicate UIDs.";
          const err = msg => new Error(`[new GlobalManager()] ${msg}`);

          /* Ensure the map is a proper `new Map()` parameter. */
          if (!validate.isMap(map)) throw err(notMapError);

          /* Determine type and ensure this is an `Array` of entries. */
          map = Array.isArray(map) ? map : Array.from(map.entries());

          /* Extract the value array and remove any existing prefixes. */
          map = map.map(entry => {
            const split = entry[1].split(DELIM);
            return [entry[0], split[split.length - 1]];
          });

          /* Validate the raw strings as compliant UID strings AND actually unique. */
          if (!validate.isUidMap(map.map(x => x[1]))) throw err(notUIDError);

          /* If applicable, add the current prefix to each UID. */
          prefix && (map = map.map(x => [x[0], `${prefix}${DELIM}${x[1]}`]));
        }

        /* Return an array [key: any, uid: string][] or undefined. */
        return map;
      },
    };

    /**
     * Handle params type and validation.
     */
    (() => {
      /**
       * Determine parameter type and assign appropriately.
       */
      params = {
        prefix:
          typeof params === "string"
            ? params
            : typeof params === "object" && params.hasOwnProperty("prefix")
            ? params.prefix
            : undefined,
        map: validate.isMap(params)
          ? params
          : typeof params === "object" && params.hasOwnProperty("map")
          ? params.map
          : undefined,
      };

      /**
       * If defined, validate the input map as a valid `GlobalManager` map parameter.
       * Strip any existing prefix off of the UIDs, validate each as a compliant string,
       * and then prefix the current prefix string to the UIDs. Throws appropriate errors
       * in the case any check fails.
       */
      params.map = validate.validMapParam(params.map, params.prefix);
    })();

    /**
     * Holding and organizing private properties.
     */
    const $ = {
      /**
       * Primary container for holding key:UID associations.
       * Stays in sync with `$.uidMap`.
       */
      keyMap: new Map(params.map),

      /**
       * Reversed `$.keyMap`. Used for faster lookup via UID.
       * Stays in sync with `$.keyMap`.
       */
      uidMap: new Map(),

      /**
       * If this is defined, each generated UID will be prefixed with `${prefix}${DELIM}`.
       */
      prefix: typeof params.prefix === "string" ? params.prefix : undefined,
    };

    /**
     * Holding and organizing private methods.
     */
    const _ = {
      /**
       * Check if a UID already exists in the map which means... it's not unique.
       * @param {string} uid
       * @returns {boolean}
       */
      mapIncludesId: uid => $.uidMap.has(uid),

      /**
       * Handles generating RFC4122 version 4 unique identifiers via kdjs-uuid.
       */
      uidgenerator: getUuidGenerator(),

      /**
       * If defined, add the prefix to the UID string separated by the `DELIM` delimiter.
       */
      addPrefix: id => ($.prefix ? `${$.prefix}${DELIM}${id}` : id),

      /**
       * Convert a Map<[key, uid][]> to  Map<[uid, key][]>.
       * @param {[any, string][]} keyMap
       * @returns {[string, any][]}
       */
      convertKeyMapToUidMap: keyMap => {
        return new Map(Array.from(keyMap.entries()).map(x => [x[1], x[0]]));
      },
    };

    /**
     * Wrap logic for public members.
     */
    const self = {
      generateUidFor: key => {
        let id = _.uidgenerator.generate();
        let prefixedId = _.addPrefix(id);
        while (validate.isUid(id) && _.mapIncludesId(prefixedId)) {
          id = _.uidgenerator.generate();
          prefixedId = _.addPrefix(id);
        }
        if (!validate.isUid(id)) throw new Error("error generating new UID");
        id = prefixedId;
        $.keyMap.has(key) && self.deleteEntryForKey(key);
        $.keyMap.set(key, id) && $.uidMap.set(id, key);
        return id;
      },
      hasKeyFor: uid => $.uidMap.has(uid),
      hasUidFor: key => $.keyMap.has(key),
      getKeyFor: uid => $.uidMap.get(uid),
      getUidFor: key => $.keyMap.get(key),
      set: (key, uid) => {
        /* Avoid duplicate keys and uids. */
        if ($.uidMap.has(uid)) self.deleteEntryForUid(uid);
        else if ($.keyMap.has(key)) self.deleteEntryForKey(key);
        $.uidMap.set(uid, key) && $.keyMap.set(key, uid);
      },
      keys: () => Array.from($.keyMap.keys()),
      uids: () => Array.from($.uidMap.keys()),
      entries: () => Array.from($.keyMap.entries()),
      deleteEntryForKey: key => {
        const uid = $.keyMap.get(key);
        return (
          uid &&
          $.keyMap.delete(key) &&
          $.uidMap.has(uid) &&
          $.uidMap.delete(uid)
        );
      },
      deleteEntryForUid: uid => {
        const key = $.uidMap.get(uid);
        return (
          key &&
          $.uidMap.delete(uid) &&
          $.keyMap.has(key) &&
          $.keyMap.delete(key)
        );
      },
      deleteAllEntries: () => {
        $.keyMap.clear();
        $.uidMap.clear();
        return $.keyMap.size === 0 && $.uidMap.size === 0;
      },
      removePrefixFrom: uid => {
        const split = uid.split(DELIM);
        return split[split.length - 1];
      },
      isValidUid: uid => {
        uid = _.removePrefix(uid);
        return validate.isUid();
      },
      prefix: prefix => {
        if (typeof prefix === "string") {
          let keyMap = Array.from($.keyMap.entries());
          let uidMap = Array.from($.uidMap.entries());

          /* If there is an old prefix, remove prefixes. */
          if ($.prefix) {
            keyMap = keyMap.map(entry => [
              entry[0],
              self.removePrefix(entry[1]),
            ]);
            uidMap = uidMap.map(entry => [
              self.removePrefix(entry[0]),
              entry[1],
            ]);
          }

          /*
           * Set the new prefix. Passing an empty string will remove the prefixes,
           * but the $.prefix variable will be set as undefined.
           */
          $.prefix = prefix.length > 0 ? prefix : undefined;

          /* If there is a new prefix, add the new prefixes. */
          if ($.prefix) {
            keyMap = keyMap.map(entry => [entry[0], _.addPrefix(entry[1])]);
            uidMap = uidMap.map(entry => [_.addPrefix(entry[0]), entry[1]]);
          }

          /* Update instance maps. */
          $.keyMap = new Map(keyMap);
          $.uidMap = new Map(uidMap);
        }

        return $.prefix;
      },

      setMap: map => {
        if (map) {
          $.keyMap = validate.validMapParam(map, $.prefix);
          $.uidMap = _.convertKeyMapToUidMap($.keyMap);
          return $.keyMap && $.uidMap;
        }
        return false;
      },
    };

    /**
     * Expose public API.
     */
    (() => {
      /**
       * Generate RFC4122 version 4 compliant unique identifier using `window.crypto`
       * (fallback to `Math.random()`) and store a key:UID association in the internal
       * `Map`. Checks against the local store holding previously generated UIDs to
       * ensure there are no duplicates in use. Returns the newly generated UID.
       * @param {any} key - Target to associate with the new UID.
       * @returns {string} - The new UID string, including prefix if applicable.
       */
      this.generateUidFor = key => self.generateUidFor(key);

      /**
       * Generate RFC4122 version 4 compliant unique identifier using `window.crypto`
       * (fallback to `Math.random()`) and store a key:UID association in the internal
       * `Map`. Checks against the local store holding previously generated UIDs to
       * ensure there are no duplicates in use. Returns the newly generated UID.
       * @note Alias for `this.generateUidFor(key)`.
       * @param {any} key - Target to associate with the new UID.
       * @returns {string} - The new UID string, including prefix if applicable.
       */
      this.manage = key => self.generateUidFor(key);

      /**
       * Check if there is an existing key for the given uid.
       * @param {string} uid
       * @returns {boolean}
       */
      this.hasKeyFor = uid => self.hasKeyFor(uid);

      /**
       * Check if there is an existing UID for the given key.
       * @param {any} key
       * @returns {boolean}
       */
      this.hasUidFor = key => self.hasUidFor(key);

      /**
       * Retrieve the key for the associated UID string.
       * @param {string} uid
       * @returns {any}
       */
      this.getKeyFor = uid => self.getKeyFor(uid);

      /**
       * Retrieve the key for the associated UID string.
       * @note Alias for `this.getKeyFor(uid)`.
       * @param {string} uid
       * @returns {any}
       */
      this.retrieve = uid => self.getKeyFor(uid);

      /**
       * Retrieve the UID string for the associated key.
       * @param {any} key
       * @returns {string}
       */
      this.getUidFor = key => self.getUidFor(key);

      /**
       * Explicitly set a key:uid mapping.
       */
      this.set = (key, uid) => self.set(key, uid);

      /**
       * Retrieve a new array containing all keys held in the map.
       * @returns {any[]}
       */
      this.keys = () => self.keys();

      /**
       * Retrieve a new array containing all values held in the map.
       * @returns {string[]}
       */
      this.uids = () => self.uids();

      /**
       * Retrieve a new array containing individual key:UID associations
       * `[key, UID]` for each entry.
       * @returns {[any, string][]}
       */
      this.entries = () => self.entries();

      /**
       * Delete a key:UID association for a given key.
       * Permanently deletes the UID and releases the reference to the key.
       * @note This operation is unrecoverable.
       * @param {any} key
       * @returns {boolean} - Success report.
       */
      this.deleteEntryForKey = key => self.deleteEntryForKey(key);

      /**
       * Delete a key:UID association for a given UID string.
       * Permanently deletes the UID and releases the reference to the key.
       * @note This operation can not be recovered.
       * @param {string} uid
       * @returns {boolean} - Success report.
       */
      this.deleteEntryForUid = uid => self.deleteEntryForUid(uid);

      /**
       * Delete all currently held target:UID associations.
       * Permanently deletes all UIDs and releases all references to keys.
       * @note This operation is unrecoverable.
       * @returns {boolean} - Success report.
       */
      this.deleteAllEntries = () => self.deleteAllEntries();

      /**
       * Set the current Map. Validates the input with errors handling, and applies the
       * appropriate prefix if applicable.
       * @param {[string, any][]} map
       * @returns {boolean} - Success report.
       */
      this.setMap = map => self.setMap(map);

      /**
       * Get or set the prefix. Passing a new `string` will update all stored UIDs
       * and will prepare all new UIDs with that prefix. Passing an empty `string`
       * will remove all existing prefixes, but the `prefix` variable will be set
       * as `undefined`. Always returns the current `prefix`.
       * @param {string} [prefix]
       * @returns {string|undefined}
       */
      this.prefix = prefix => self.prefix(prefix);

      /**
       * Remove the prefix from a UUID string retrieved from any instance of `GlobalManager`.
       * @param {string} uid
       * @returns {string}
       */
      this.removePrefixFrom = uid => self.removePrefixFrom(uid);

      /**
       * Validate a string as a RFC4122 version 4 compliant unique identifier. Automatically
       * removes any prefix applied by `GlobalManager` before validating.
       * @param {string} uid
       * @returns {boolean}
       */
      this.isValidUid = uid => self.isValidUid(uid);
    })();

    /**
     * Init
     */
    (() => {
      /* On initialization, redefine public members to be read-only. */
      Object.keys(this).forEach(key => {
        Object.defineProperty(this, key, {
          value: this[key],
          writable: false,
          enumerable: true,
        });
      });

      /* Generate the initial uidMap. */
      $.uidMap = _.convertKeyMapToUidMap($.keyMap);

      params = undefined;
    })();
  }
}

(function(declareExports) {
  const root = window;
  if (root && typeof root.define === "function" && root.define.amd) {
    root.define(["exports"], declareExports);
  } else if (typeof module === "object" && typeof exports === "object") {
    exports !== null && declareExports(exports);
    module !== null && (module.exports = exports);
  } else if (root) {
    declareExports((root.kd = root.kd || {}));
  } else {
    console.warn(
      "Unable to load as ES module. Use AMD, CJS, add an export, or use as non-module script.",
    );
  }
})(function(exports) {
  exports.GlobalManager = GlobalManager;
});

/*

  // CommonJS / Node

  import { GlobalManager } from "./GlobalManager";
  console.log( new GlobalManager() );

  // AMD / Require

  require(["GlobalManager"], function(GlobalManager) {
    console.log( new GlobalManager() );
  });

  // Non-module

  const GlobalManager = window.kd.GlobalManager;
  console.log( new GlobalManager() );

*/
